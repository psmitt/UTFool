import java.io.IOException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.HashMap
import java.util.HashSet
import java.util.Set

â–  The
  â‰£ Symbol
    DELIMITER
    OPERATOR
    KEYWORD
    ALIAS
    EMBEDDED_CODE
    EXPLETIVE
    RESERVED_WORD
    PREFIX

  Â§ static
    Â§ final
      symbolsâ¦‚ HashMapâŸ¨String, SymbolâŸ©Â° Â· symbol -> lexical category

      delimitedSequencesâ¦‚      HashMapâŸ¨String, StringâŸ©Â° Â· opening delimiter -> delimited sequence (e.g.literal)
      closingDelimitersâ¦‚       HashMapâŸ¨String, StringâŸ©Â° Â· opening delimiter -> closing delimiter
      interpolationDelimitersâ¦‚ HashSetâŸ¨StringâŸ©Â°         Â· interpolation opening delimiters

      operatorsâ¦‚        HashMapâŸ¨String, StringâŸ©Â°  Â· symbol -> operation
      precedencesâ¦‚      HashMapâŸ¨String, IntegerâŸ©Â° Â· operation -> precedence
      aritiesâ¦‚          HashMapâŸ¨String, IntegerâŸ©Â° Â· operation -> arity
      leftAssociativesâ¦‚ HashSetâŸ¨StringâŸ©Â°          Â· left associative operations

      keywordsâ¦‚         HashMapâŸ¨String, StringâŸ©Â°      Â· symbol -> ultimate non-terminal syntactic unit
      aliasesâ¦‚          HashMapâŸ¨String, StringâŸ©Â°      Â· symbol -> code replacement (e.g. name or reference)
      embeddedCodeâ¦‚     HashMapâŸ¨String, SetâŸ¨StringâŸ©âŸ©Â° Â· language name -> embedded code
      expletivesâ¦‚       HashSetâŸ¨StringâŸ©Â°              Â· symbols to drop
      reservedWordsâ¦‚    HashMapâŸ¨String, SetâŸ¨StringâŸ©âŸ©Â° Â· language name -> reserved words

    â–¶ collisionError
    âº symbolâ¦‚ String
    âº categoryâ¦‚ Symbol
      System.err.println "
        Collision of Symbols (â¸¨category.nameÂ°â¸© vs.
        â¸¨(symbols.get symbol).nameÂ°â¸©): â¸¨symbolâ¸©"
      System.exit 1

    â–¶ registerSymbol
    âº symbolâ¦‚ StringBuilder
    âº categoryâ¦‚ Symbol
      completeSequenceâ¦‚ String: symbol.toStringÂ°
      if symbols.containsKey completeSequence
         âˆ¢ category
           â¬© OPERATOR
             if symbols.get completeSequence = Symbol.DELIMITER
                collisionError completeSequence, category
           â¬© KEYWORD
             âˆ¢ symbols.get completeSequence
               â¬© DELIMITER, OPERATOR, KEYWORD
                 collisionError completeSequence, category
           â¬© ALIAS
             if symbols.get completeSequence = Symbol.ALIAS
                collisionError completeSequence, category
      if Â¬ symbols.containsKey completeSequence
        or symbols.get completeSequence = Symbol.PREFIX
           symbols.put completeSequence, category

      âƒ«register prefixes
      symbol.setLength symbol.lengthÂ° - 1
      ðŸ”ï¹– symbol.lengthÂ° > 0 and Â¬ symbols.containsKey symbol.toStringÂ°
          symbols.put symbol.toStringÂ°, Symbol.PREFIX
          symbol.setLength symbol.lengthÂ° - 1

  static Â· initializer block
    try
        baseDirectoryâ¦‚ Path: Paths.get "."

        âˆ€ line âˆˆ Files.readAllLines Paths.get baseDirectory.toStringÂ°, "delimiters.tsv" â¦‚ String
          delimitersâ¦‚ String[]: line.trimÂ°.split "\\s*\\t+\\s*"
          if delimiters.length > 1 Â· not an empty line
             registerSymbol *(StringBuilder delimiters[0]), Symbol.DELIMITER
             delimitedSequences.put delimiters[0], delimiters[1]
             âˆ¢ delimiters[2]
               â¬© "LineBreak" â­† closingDelimiters.put delimiters[0], "\n"
               â¬© "Space"     â­† closingDelimiters.put delimiters[0], " "
               else
                 registerSymbol *(StringBuilder delimiters[2]), Symbol.DELIMITER
                 closingDelimiters.put delimiters[0], delimiters[2]
             âˆ¢ delimiters[1]
               â¬© "Interpolation"
                 interpolationDelimiters.add delimiters[0]
               â¬© "Expression", "Array", "TypeList"
                 delimitedSequences.put delimiters[2], delimiters[1]

        precedenceâ¦‚ Integer: 0
        âˆ€ line âˆˆ Files.readAllLines Paths.get baseDirectory.toStringÂ°, "operators.tsv" â¦‚ String
          operatorâ¦‚ String[]: line.trimÂ°.split "\\s*\\t+\\s*"
          if operator.length â‰¤ 1 Â· empty line
             precedenceâ—¥
          else
              registerSymbol *(StringBuilder operator[0]), Symbol.OPERATOR
              operators.put operator[0], operator[1]
              precedences.put operator[1], precedence
              âˆ¢ operator[2]
                â¬© "unary postfix" â­† arities.put operator[1], 0
                â¬© "unary prefix"  â­† arities.put operator[1], 1
                â¬© "binary"        â­† arities.put operator[1], 2
                â¬© "ternary"       â­† arities.put operator[1], 3
              if operator[3] â‰ˆ "left"
                 leftAssociatives.add operator[1]
              if operator[1] â‰ˆ "ListSeparator"
                 precedences.put "FunctionCall", precedence
                 arities.put "FunctionCall", 2

        âˆ€ line âˆˆ Files.readAllLines Paths.get baseDirectory.toStringÂ°, "keywords.tsv" â¦‚ String
          wordsâ¦‚ String[]: line.trimÂ°.split "\\s*\\t+\\s*"
          if words.length > 1 Â· not an empty line
             registerSymbol *(StringBuilder words[0]), Symbol.KEYWORD
             keywords.put words[0], words[1]

        âˆ€ line âˆˆ Files.readAllLines Paths.get baseDirectory.toStringÂ°, "aliases.tsv" â¦‚ String
          aliasâ¦‚ String[]: line.trimÂ°.split "\\s*\\t+\\s*"
          if alias.length > 1 Â· not an empty line
             registerSymbol *(StringBuilder alias[0]), Symbol.ALIAS
             aliases.put alias[0], alias[1]

        âˆ€ entry âˆˆ Files.newDirectoryStream baseDirectory, "embedded_code_*.tsv" â¦‚ Path
          fileNameâ¦‚ String: entry.getFileName().toStringÂ°
          languageNameâ¦‚ String: fileName.(substring "embedded_code_".lengthÂ°, fileName.lengthÂ° - 4).trimÂ°
          embeddedCode.put languageName, *HashSetâŸ¨StringâŸ©Â°
          âˆ€ line âˆˆ Files.readAllLines entry.getFileNameÂ° â¦‚ String
            registerSymbol *(StringBuilder line), Symbol.EMBEDDED_CODE
            embeddedCode.(get languageName).add line

        âˆ€ line âˆˆ Files.readAllLines Paths.get baseDirectory.toStringÂ°, "expletives.tsv" â¦‚ String
          expletiveâ¦‚ String: line.trimÂ°
          registerSymbol *(StringBuilder expletive), Symbol.EXPLETIVE
          expletives.add expletive

        âˆ€ entry âˆˆ Files.newDirectoryStream baseDirectory, "reserved_words_*.tsv" â¦‚ Path
          fileNameâ¦‚ String: entry.getFileName().toStringÂ°
          languageNameâ¦‚ String: fileName.(substring "reserved_words_".lengthÂ°, fileName.lengthÂ° - 4).trimÂ°
          reservedWords.put languageName, *HashSetâŸ¨StringâŸ©Â°
          âˆ€ line âˆˆ Files.readAllLines entry.getFileNameÂ° â¦‚ String
            wordâ¦‚ String[]: line.trimÂ°.split "\\s*\\t+\\s*"
            if word.length = 1
            or Â¬(word[1] â‰ˆ "KEY") âˆ§ Â¬(word[1] â‰ˆ "COD") âˆ§ Â¬(word[1] â‰ˆ "NAM")
               registerSymbol *(StringBuilder word[0]), Symbol.RESERVED_WORD
               reservedWords.(get languageName).add word[0]

    catch eâ¦‚ IOException
          System.out.println "â¸¨e.getClassÂ°.getSimpleNameÂ°â¸© - â¸¨e.getMessageÂ°â¸©"
