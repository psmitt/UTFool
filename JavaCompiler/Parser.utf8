import java.util.LinkedList

â–  Parser 
  operandStackâ¦‚ LinkedListâŸ¨ExpressionâŸ©
  operatorStackâ¦‚ LinkedListâŸ¨TokenâŸ©
  wasOperandâ¦‚ boolean
  potentialâ¦‚ Expression

  â–¶ resetâ¦‚ Parser
    operandStack: = *LinkedListâŸ¨ExpressionâŸ©Â°
    operatorStack: *LinkedListâŸ¨TokenâŸ©Â°
    wasOperand: false
    potential: null
    return this

  â–¶ reduceOperationStack
    rightâ¦‚ Expression: operandStack.removeLastÂ°
    lastOperatorâ¦‚ Token: operatorStack.removeLastÂ°
    operandStack.add *Expression lastOperator, (
      if The.arities.get lastOperator.value = 1 Â· unary operator
      then null else operandStack.removeLastÂ°), right

  Â·Â·Â· 
  Parse the line tokens from the given index and
  Return the index of token following the expression
  Â·Â·Â·
  â–¶ parseâ¦‚ int
  âº lineâ¦‚ Line
  âº iâ¦‚ int
    tokensâ¦‚ LinkedListâŸ¨TokenâŸ©: line.tokens
    limitâ¦‚ int: tokens.sizeÂ°
    coalesceâ¦‚ boolean: false
    existenceâ¦‚ boolean: false
    ğŸ”ï¹– i < limit
        tokenâ¦‚ Token: tokens.get iâ—¥

        if token â‰ˆ Lex.KEY, "class" Â· anonymous class: unary postfix
           if operatorStack.getLastÂ°.value â‰ˆ "New" Â· unary prefix
              operandStack.add *Expression operatorStack.removeLastÂ°, âˆ…,
                                           operandStack.removeLastÂ°
           operandStack.add *Expression token, operandStack.removeLastÂ°, âˆ…
           return i - 1 Â· return token's index

        if  token.name = Lex.STR
        and wasOperand
        and operandStack.getLastÂ°.root.name = Lex.STR
        ÍConcatenate consecutive strings after interpolation:
            previousStringâ¦‚ Expression: operandStack.removeLastÂ°
            previousString.root.value âŠ•: token.value
            operandStack.add previousString
            continue

        if token â‰ˆ Lex.OPR, "TernaryTrue"
           nextâ¦‚ Token: tokens.get i
           if next â‰ˆ Lex.OPR, "TernaryFalse" and not coalesce
              tokens.add â—£i, *Token Lex.NAM, "null"
              limitâ—¥
              token: *Token Lex.OPR, "NotIdentical"
              coalesce: true
           else if next.name = Lex.OPR
               and The.arities.get next.value = 2
               and not existence
                   tokens.add  i, *Token Lex.OPR, "TernaryFalse"
                   tokens.add  i, *Token Lex.NAM, "false"
                   tokens.add â—£i, *Token Lex.NAM, "null"
                   limit +: 3
                   token: *Token Lex.OPR, "Identical"
                   existence: true

        argumentâ¦‚ Expression: null

        âˆ¢ token.name

          â¬© KEY Â· anonymous function
            âˆ¢ token.value
              â¬© "parameter", "function"
              â€¼ return i - 1 Â· return token's index
            fallthrough

          â¬© BEG
            parserâ¦‚ ParserÂ°
            i: parser.resetÂ°.parse line, i
            if token.value â‰ˆ "Array" Â· array reference
               argument: *Expression (*Token Lex.OPR, "Array"),
                         (wasOperand ? operandStack.removeLastÂ° ! âˆ…),
                          parser.getExpressionÂ°
               operandStack.add argument
               break
            if token.value â‰ˆ "Interpolation" Â· string interpolation
               argument: *Expression (*Token Lex.OPR, "Expression"),
                                      parser.getExpressionÂ°, âˆ…
               operandStack.add *Expression â†µ
                               (*Token Lex.OPR, "Concatenation"),
                                operandStack.removeLastÂ°, argument
               operatorStack.add *Token Lex.OPR, "Concatenation"
               operandStack.add *Expression (*Token Lex.STR), âˆ…, âˆ…
               wasOperand: true
               break
            if token.value â‰ˆ "Expression" Â· parenthetical expression
                argument: *Expression(*Token Lex.OPR, "Expression"),
                                      parser.getExpressionÂ°, âˆ…
            fallthrough

          â¬© NAM, NUM, CHR, STR
            argument: *Expression token, âˆ…, âˆ… unless Lex.BEG = token.name
            unless wasOperand
                   wasOperand: true
                   operandStack.add argument
                   if argument.root â‰ˆ Lex.KEY, "function"
                   or argument.root â‰ˆ Lex.KEY, "parameter"
                      return i - 1 Â· return token's index
                   break

            token: *Token Lex.OPR, "FunctionCall"
            fallthrough

          â¬© OPR
            if The.arities.get token.value = 0 Â· unary postfix
               operandStack.add *Expression token,
                                            operandStack.removeLastÂ°, âˆ…
               break
            if The.arities.get token.value = 1 âˆ§ wasOperand Â· unary prefix
               ğŸ”ï¹— operatorStack.isEmptyÂ° or
                  The.precedences.get "FunctionCall" â‰¤
                  The.precedences.get operatorStack.getLastÂ°.value
                      reduceOperationStackÂ°
               operatorStack.add *Token Lex.OPR, "FunctionCall"
            else
               ğŸ”ï¹— operatorStack.isEmptyÂ° or
                  The.precedences.get token.value â‰¤ 
                  The.precedences.get operatorStack.getLastÂ°.value
                      reduceOperationStackÂ°
            if Â¬ operatorStack.isEmptyÂ°
            and  The.precedences.get token.value =
                 The.precedences.get operatorStack.getLastÂ°.value
            and  The.leftAssociatives.contains token.value
                 rightâ¦‚ Expression: operandStack.removeLastÂ°
                 operandStack.add *Expression operatorStack.removeLastÂ°,
                                   operandStack.removeLastÂ°, right
                 ÍDecompose chained relations:
                 âˆ¢ token.value
                   â¬© "Identical", "NotIdentical", "Equal", "NotEqual",
                     "Less", "LessEqual", "Greater", "GreaterEqual"
                     operandStack.add right
                     operatorStack.add *Token Lex.OPR, "And"
            operatorStack.add token
            if token â‰ˆ Lex.OPR, "NotIdentical" and coalesce
            or token â‰ˆ Lex.OPR, "Identical" and existence
               potential: operandStack.getLastÂ°
            if token â‰ˆ Lex.OPR, "TernaryTrue" and coalesce
               operandStack.add potential
               coalesce: false
            if token â‰ˆ Lex.OPR, "TernaryFalse" and existence
               operandStack.add potential
               existence: false
            wasOperand: token.value â‰ˆ "FunctionCall"
            if wasOperand
               operandStack.add argument
               if argument.root â‰ˆ Lex.KEY, "function"
               or argument.root â‰ˆ Lex.KEY, "parameter" Â· anonymous function
                  return i - 1 Â· return token's index

          â¬© END
            return i

          â€¼ return i - 1 Â· return token's index
 
    return i

  â–¶ getExpressionâ¦‚ Expression
    ğŸ”ï¹– operandStack.sizeÂ° > 1 Â· wrap up
        reduceOperationStackÂ°
    unless operatorStack.isEmptyÂ°
        or The.arities.get operatorStack.getLastÂ°.value â‰  1 Â· unary prefix
        reduceOperationStackÂ°
    return operandStack.peekLastÂ°
