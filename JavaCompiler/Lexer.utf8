Â·Â·Â·
Lexical Analyser of Source Lines
[Indentation][SectionSign][EmbeddedCode][Tokens][LineComment]
Â·Â·Â·
import java.util.LinkedList
import java.util.HashMap
import java.util.Map

â–  Lexerâ¦‚ DFA
  stateâ¦‚ Lex

  linesâ¦‚ LinkedListâŸ¨LineâŸ©   Â· final output
  tokensâ¦‚ LinkedListâŸ¨TokenâŸ© Â· current working item for building next line

  indentationsâ¦‚ LinkedListâŸ¨StringâŸ©Â° Â· indentation stack
  indentationâ¦‚ StringBuilderÂ°       Â· current indentation

  closingDelimiterâ¦‚ String Â· stop symbol for the current simple delimited sequence
  stopInterpolationâ¦‚ String Â· stop symbol for interpolation (embedded lexical analysis)

  dfaâ¦‚ HashMapâŸ¨Lex, DFAâŸ©Â° Â· Helper DFAs for Literals

  symbolâ¦‚ String Â· found Alias, Delimiter, Keyword, Operator, EmbeddedCode or Expletive
  prefixâ¦‚ StringBuilderÂ° Â· current working item for finding next symbol

  â–¶ new
    reset null

  â–¶ new
  âº sourceâ¦‚ String
    reset null
    analyse source.replaceAll â†µ
       "(\\r\\n)|\\u000B|\\u000C|\\u2028|\\u2029", "\n" Â· LineBreak
    if source.charAt source.length() - 1 â‰  '\n' Â· final empty line missing
       consume '\n' Â· simulate final empty line

  â–¶ reset
  âº startInterpolationâ¦‚ String
    lines: *LinkedListâŸ¨LineâŸ©Â°
    tokens: *LinkedListâŸ¨TokenâŸ©Â°

    if âˆƒ startInterpolation
         stopInterpolation: The.closingDelimiters.get startInterpolation
         state: Lex.WSP Â· Initial state for interpolation: WhiteSpace
    else
         stopInterpolation: null
         state: Lex.IND Â· Initial state for analysis: Indentation
         indentations.clearÂ°
         indentation.setLength 0

    dfa.put Lex.NUM, *NumberDFAÂ°
    dfa.put Lex.CHR, *CharacterDFAÂ°
    dfa.put Lex.STR, *StringDFAÂ°
    dfa.put Lex.TXT, *TextDFAÂ°

    symbol: null
    prefix.setLength 0

  â–¶ analyseâ¦‚ boolean
  âº sourceâ¦‚ String
    âˆ€ i âˆˆ 0 â€¦ source.lengthÂ°
      return false unless consume source.charAt i
    return true

  â–¶ consumeâ¦‚ boolean
  âº câ¦‚ Character
    âˆ¢ state
      â¬© IND Â· Indentation
        if c = '\n' Â· drop empty line
           indentation.setLength 0
           tokens: *LinkedListâŸ¨TokenâŸ©Â°
           return true
        if c.isWhitespace c
           indentation.append c
           return true
        ÍEnd of Indentation
        thisIndentationâ¦‚ String: indentation.toStringÂ°
        lastIndentationâ¦‚ String: indentations.peekLastÂ° âˆ ""
        unless thisIndentation â‰ˆ lastIndentation Â· Indentation CHANGE
          if thisIndentation.startsWith lastIndentation Â· start of block
             indentations.add thisIndentation
          else if lastIndentation.startsWith thisIndentation Â· end of block(s)
            ğŸ”ï¹– indentations.sizeÂ° > 0 and
               Â¬ thisIndentation.startsWith indentations.getLastÂ°
               indentations.removeLastÂ°
            if indentations.isEmptyÂ°
               indentations.add thisIndentation unless thisIndentation.isEmptyÂ°
            else
               indentations.add thisIndentation unless â†µ
                                thisIndentation â‰ˆ indentations.getLastÂ°
          else
            tokens.add *Token Lex.ERR, thisIndentation âŠ• c âŠ•
               System.lineSeparatorÂ° âŠ• "^ INDENTATION MISMATCH ERROR"
            return false
        indentation.setLength 0
        state: Lex.WSP
        fallthrough

      â¬© WSP Â· Inline WhiteSpace
        if c = '\n'
           if âˆ„ stopInterpolation
                unless tokens.isEmptyÂ°
                       lines.add *Line indentations.sizeÂ°, tokens
                indentation.setLength 0
                tokens: *LinkedListâŸ¨TokenâŸ©Â°
                state: Lex.IND
           return true

        return true if c.isWhitespace c

        state: Lex.SYM
        fallthrough

      â¬© SYM
        prefix.append c
        if The.symbols.containsKey prefix.toStringÂ°
           if The.symbols.get prefix.toStringÂ° â‰  The.Symbol.PREFIX Â· real symbol found
              symbol: prefix.toStringÂ°
           return true
        âƒ«Check if the beginning of the prefix can be a name, longer than the symbol found
        if c.isJavaIdentifierStart prefix.charAt 0
           isNameâ¦‚ boolean: true
           âˆ€ i âˆˆ 1 â€¦ prefix.lengthÂ°
             if Â¬ c.isJavaIdentifierPart prefix.charAt i
             and (âˆ„ symbol or i â‰¤ symbol.lengthÂ°)
                 isName: false
           if isName
              state: Lex.NAM
              recycleâ¦‚ String: prefix.toStringÂ°
              symbol: null
              prefix.setLength 0
              return analyse recycle
        if âˆƒ symbol
           recycleâ¦‚ String
           if The.symbols.get symbol = The.Symbol.ALIAS
              recycle: (The.aliases.get symbol) âŠ•
                       (prefix.substring symbol.lengthÂ°)
           else
              consume symbol
              recycle: prefix.substring symbol.lengthÂ°
           symbol: null
           prefix.setLength 0
           return analyse recycle
        if c.isJavaIdentifierStart prefix.charAt 0
           prefixTailâ¦‚ String: prefix.substring 1
           prefix.setLength 1
           state: Lex.NAM
           return analyse prefixTail
        if c.isDigit prefix.charAt 0
           state: Lex.NUM
           dfa.(get state).reset null
           prefixTailâ¦‚ String: prefix.toStringÂ°
           prefix.setLength 0
           return analyse prefixTail
        tokens.add *Token Lex.SYM, prefix.substring 0, 1
        prefixTailâ¦‚ String: prefix.substring 1
        prefix.setLength 0
        state: Lex.WSP
        return analyse prefixTail

      â¬© NAM
        if c.isJavaIdentifierPart c
           prefix.append c
           return true
        tokens.add *Token Lex.NAM, prefix.toStringÂ°
        prefix.setLength 0
        state: Lex.WSP
        return consume c

      âƒ«complex delimited sequences
      â¬© NUM, CHR, STR, TXT
        unless dfa.(get state).consume c
          tokens.addAll dfa.(get state).getTokensÂ°
          state: Lex.WSP
          return consume c
        return true

      âƒ«simple delimited sequences
      â¬© BLC, COD, COM, REG, REB
        candidateâ¦‚ String: âˆƒ symbol ? symbol âŠ• c ! c.toStringÂ°
        if closingDelimiter.startsWith candidate
           if closingDelimiter â‰ˆ candidate
              if state â‰  Lex.BLC Â· drop block comments
                 tokens.add *Token (state = Lex.REB ? Lex.REG ! state),
                                    prefix.toStringÂ°.trimÂ°
              prefix.setLength 0
              symbol: null
              âˆ¢ state
                â¬© COM
                  lines.add *Line indentations.sizeÂ°, tokens
                  indentation.setLength 0
                  tokens: *LinkedListâŸ¨TokenâŸ©Â°
                  state: Lex.IND
                â¬© REG, REB
                  state: Lex.FLG
                â€¼ state: Lex.WSP
              return true
          symbol: candidate
        else
          if state = Lex.REB and c = '\n'
            regLinesâ¦‚ String[]: prefix.toStringÂ°.split "\n"
            âˆ€ openingDelimiter âˆˆ The.delimitedSequences.keySetÂ° â¦‚ String
              if "LineComment" â‰ˆ The.delimitedSequences.get openingDelimiter
                 regExpsâ¦‚ String[]: regLines[regLines.length - 1].split openingDelimiter
                 if regExps.length > 1
                    if regLines.length < 2 Â· first line: promote comment
                       lineCommentâ¦‚ LinkedListâŸ¨TokenâŸ©Â°
                       lineComment.add *Token Lex.COM, regExps[1]
                       lines.add *Line indentations.sizeÂ°, lineComment
                       prefix.setLength 0
                       prefix.append "\n"
                    else Â· remove comment from prefix and line
                       prefix.setLength prefix.length() -
                               regLines[regLines.length - 1].lengthÂ°
                       regLines[regLines.length - 1]: regExps[0]
            if regLines.length > 2
               prefix.setLength prefix.lengthÂ° - 1 Â· remove '\n'
               prefix.append "|"
            if regLines.length > 1
               prefix.(append regLines[regLines.length - 1].trimÂ° â¨­ "\n")
          else
            prefix.append candidate
          symbol: null
        return true

      â¬© FLG Â· Regular Parser Flags
        âˆ¢ c
          â¬© 'g', 'i', 'm', 'u', 'y'
            if 0 > prefix.indexOf String.valueOf c
               prefix.append c
               return true
        if c.isLetterOrDigit c
           tokens.add *Token Lex.ERR, prefix.toStringÂ° âŠ• c âŠ•
                      " < INVALID REGULAR EXPRESSION FLAG"
           prefix.setLength 0
           state: Lex.WSP
        else
           tokens.add *Token Lex.FLG, prefix.toStringÂ°
           prefix.setLength 0
           state: Lex.WSP
           return consume c

        return true

      else return false Â· IPE, ERR

  â–¶ getTokensâ¦‚ LinkedListâŸ¨TokenâŸ©
    return tokens

  â–¶ appendBack âº iâ¦‚ int Â· append line #i to the previous line
    ğŸ”ï¹– lines.(get â—£i).tokens.getFirstÂ°.name = Lex.COM Â· drop previous comment line
       lines.remove i
    if lines.(get i).tokens.getLastÂ°.name = Lex.COM Â· drop line comment
       lines.(get i).tokens.removeLastÂ°
    lines.(get i).tokens.addAll lines.(get i + 1).tokens
    lines.remove i + 1
    âƒ«reduce double indentations underneath
    âˆ€ j âˆˆ i + 1 â€¦ lines.sizeÂ°
      if lines.(get j).indentation > lines.(get i).indentation + 1
         lines.(get j).indentationâ—¢
      else break

  â–¶ appenderâ¦‚ boolean Â· true if argument cannot end a line
  âº tokenâ¦‚ Token
    â token.name = Lex.BEG
    âˆ¨ lineBreaker token
    âˆ¨ token â‰ˆ Lex.KEY, "if"
    âˆ¨ token â‰ˆ Lex.KEY, "then"
    âˆ¨ token â‰ˆ Lex.KEY, "word wrap"

  â–¶ lineBreakerâ¦‚ boolean Â· true if argument cannot start or end a line
  âº tokenâ¦‚ Token
    â token â‰ˆ Lex.KEY, "assign"
    âˆ¨ token.name = Lex.OPR
    âˆ§ Â¬ token.value â‰ˆ "Invocation"
    âˆ§ Â¬ token.value â‰ˆ "PostIncrement"
    âˆ§ Â¬ token.value â‰ˆ "PostDecrement"

  â–¶ getLinesâ¦‚ LinkedListâŸ¨LineâŸ©
    tokenâ¦‚ Token
    âƒ«Restore parameter lines before completing sections
    âˆ€ i âˆˆ 1 â€¦ lines.sizeÂ°
      if lines.(get i).tokens.getFirstÂ° â‰ˆ Lex.KEY, "parameter"
         appendBack iâ—¢
    âƒ«Complete sections
    âˆ€ i âˆˆ 0 â€¦ lines.sizeÂ°
      if lines.(get i).tokens.getFirstÂ° â‰ˆ Lex.KEY, "section"
         lines.(get i).tokens.removeFirstÂ°
         if lines.(get i).tokens.getLastÂ°.name = Lex.COM Â· drop comment
            lines.(get i).tokens.removeLastÂ°
         âˆ€ j âˆˆ i + 1 â€¦ lines.sizeÂ°
           break if lines.(get j).indentation â‰¤ lines.(get i).indentation
           if lines.(get j).indentation = lines.(get i).indentation + 1
           and lines.(get j).tokens.getFirstÂ°.name â‰  Lex.COM
               lines.(get j).tokens.addAll (
                 if lines.(get j).tokens.getFirstÂ° â‰ˆ Lex.KEY, "section"
                 then 1 Â· subsection
                 else 0), lines.(get i).tokens
           lines.(get j).indentationâ—¢
         lines.remove iâ—¢
    âƒ«Restore literal arrays
    lâ¦‚ int: 0 Â· line index
    ğŸ· walkLines
    ğŸ”ï¹– l < lines.sizeÂ°
        âƒ«Find "array" token
        tâ¦‚ int: â€1 Â· token index
        ğŸ”ï¹– â—¤t < lines.(get l).tokens.sizeÂ°
            break if lines.(get l).tokens.(get t) â‰ˆ Lex.KEY, "array"
        if t < lines.(get l).tokens.sizeÂ° Â· array found
           ğŸ· walkArray
           ğŸ”ï¹– l + 1 < lines.sizeÂ°
           and lines.(get l + 1).indentation > lines.(get l).indentation
               if lines.(get l + 1).tokens.getFirstÂ° â‰ˆ Lex.KEY, "array"
                  lâ—¥
                  continue walkLines Â· recurse nested array
               else
                  if lines.(get l).tokens.getLastÂ°.name = Lex.COM
                     lines.(get l).tokens.removeLastÂ°
                  unless lines.(get l).tokens.getLastÂ° â‰ˆ Lex.OPR, "ListSeparator"
                     lines.(get l).tokens.add *Token Lex.OPR, "ListSeparator"
                  lines.(get l).tokens.addAll lines.(get l + 1).tokens
                  lines.remove l + 1
                  continue walkArray
           lines.(get l).tokens.set t, *Token Lex.BEG, "Array"
           lines.(get l).tokens.add *Token Lex.END, "Array"
           if t = 0 âˆ§ l > 0
            âˆ§ lines.(get l - 1).indentation < lines.(get l).indentation
              if lines.(get â—£l).tokens.getLastÂ°.name = Lex.COM
                 lines.(get l).tokens.removeLastÂ°
              unless lines.(get l).tokens.getLastÂ° â‰ˆ Lex.OPR, "ListSeparator"
                 lines.(get l).tokens.add *Token Lex.OPR, "ListSeparator"
              lines.(get l).tokens.addAll lines.(get l + 1).tokens
              lines.remove l + 1
        else lâ—¥
    âƒ«Restore logical lines
    âˆ€ i âˆˆ 0 â€¦ lines.sizeÂ°
        âƒ«backward
        token: lines.(get i).tokens.getFirstÂ°
        if token.name = Lex.END or lineBreaker token
           appendBack iâ—¢
        continue if token.name = Lex.COM
        âƒ«forward
        token: lines.(get i).tokens.removeLastÂ°
        ğŸ”ï¹– i + 1 < lines.size()
        and (appender token
             âˆ¨ token.name = Lex.COM âˆ§ appender lines.(get i).tokens.getLastÂ°
             âˆ¨ lines.(get i + 1).indentation > lines.(get i).indentation
             âˆ§ (lines.(get i + 1).tokens.getFirstÂ° â‰ˆ Lex.KEY, "then" âˆ¨
                lines.(get i + 1).tokens.getFirstÂ° â‰ˆ Lex.KEY, "else")
            )
            if lines.(get i).tokens.getLastÂ° â‰ˆ Lex.KEY, "word wrap"
               lines.(get i).tokens.removeLastÂ°
            if token.name â‰  Lex.COM âˆ§ Â¬token â‰ˆ Lex.KEY, "word wrap"
               lines.(get i).tokens.add token
            lines.(get i).tokens.addAll lines.(get i + 1).tokens
            lines.remove i + 1
            âƒ«reduce double indentations underneath
            âˆ€ j âˆˆ i + 1 â€¦ lines.sizeÂ°
              break if lines.(get j).indentation â‰¤ lines.(get i).indentation + 1
              lines.(get j).indentationâ—¢
            token: lines.(get i).tokens.removeLastÂ°
        lines.(get i).tokens.add token
    âƒ«Restore ternary expressions, resolve unless and until
    token: *Token Lex.KEY, "else"
    âˆ€ i âˆˆ 0 â€¦ lines.sizeÂ°
      tâ¦‚ int
      ğŸ”ï¹– 0 < lines.(get i).tokens.indexOf token Â· inline "else"
          t: lines.(get i).tokens.indexOf token
          lines.(get i).tokens.set t, *Token Lex.OPR, "TernaryFalse"
          ğŸ”ï¹— lines.(get i).tokens.(get â—£t) â‰ˆ Lex.KEY, "then"
            Â· find "then"
          lines.(get i).tokens.set t, *Token Lex.OPR, "TernaryTrue"
          ğŸ”ï¹— lines.(get i).tokens.(get â—£t) â‰ˆ Lex.KEY, "if"
            Â· find "if"
          lines.(get i).tokens.remove t
      t: lines.(get i).tokens.indexOf *Token Lex.KEY, "until"
      if 0 â‰¤ t
      or 0 â‰¤ lines.(get i).tokens.indexOf *Token Lex.KEY, "unless"
         if t < 0 Â· "unless"
            t: lines.(get i).tokens.indexOf *Token Lex.KEY, "unless"
            lines.(get i).tokens.set t, *Token Lex.KEY, "if"
         else Â· "until"
            lines.(get i).tokens.set t, *Token Lex.KEY, "while"
         lines.(get i).tokens.add t + 1, *Token Lex.OPR, "Not"
         lines.(get i).tokens.add t + 2, *Token Lex.BEG, "Expression"
         if lines.(get i).tokens.getLastÂ°.name = Lex.COM
            lines.(get i).tokens.add lines.(get i).tokens.sizeÂ° - 1,
                         *Token Lex.END, "Expression"
         else
            lines.(get i).tokens.add *Token Lex.END, "Expression"
    â lines

  â–¶ consume âº symbolâ¦‚ String Â· assert symbol â‰  null
    if symbol â‰ˆ stopInterpolation
       state: Lex.ERR
       return
    state: Lex.WSP Â· default state after lexical elements
    âˆ¢ The.symbols.get symbol
      â¬© DELIMITER
        âˆ¢ The.delimitedSequences.get symbol
          â¬© "LineComment"       â­† state: Lex.COM
          â¬© "BlockComment"      â­† state: Lex.BLC
          â¬© "EmbeddedCode"      â­† state: Lex.COD
          â¬© "RegularExpression" â­† state: Lex.REG
          â¬© "RegularBlock"      â­† state: Lex.REB
          â¬© "Character"         â­† state: Lex.CHR
          â¬© "String"            â­† state: Lex.STR
          â¬© "Text"              â­† state: Lex.TXT
          â€¼ state: Lex.WSP

        âˆ¢ The.delimitedSequences.get symbol
          â¬© "LineComment", "BlockComment", "EmbeddedCode",
            "RegularExpression", "RegularBlock"
            closingDelimiter: The.closingDelimiters.get symbol

          â¬© "Character", "String", "Text"
            dfa.(get state).reset symbol

          â¬© "TypeList"
            if symbol â‰ˆ closingDelimiter Â· shrink type reference into a name
               typeNameâ¦‚ StringBuilder ">"
               tokenâ¦‚ Token: tokens.removeLastÂ°
               ğŸ”ï¹— token.name = Lex.BEG
                   typeName.insert 0, (token.name = Lex.OPR ? "," ! token.value)
                   token: tokens.removeLastÂ°
               tokens.add *Token Lex.NAM, tokens.removeLastÂ°.value
                                 âŠ• "<" âŠ•  typeName
            else
               closingDelimiter: The.closingDelimiters.get symbol
               tokens.add *Token Lex.BEG, "TypeList"

          â¬© "Array", "Expression"
            tokens.add *Token (if The.closingDelimiters.containsKey symbol
                               then Lex.BEG
                               else Lex.END),
                              The.delimitedSequences.get symbol

          â€¼ tokens.add *Token Lex.ERR, symbol âŠ• " < UNKNOWN DELIMITER"

      â¬© OPERATOR
        tokens.add *Token Lex.OPR, The.operators.get symbol

      â¬© KEYWORD
        tokens.add *Token Lex.KEY, The.keywords.get symbol

      â¬© EXPLETIVE
        Â· drop expletive

      â¬© EMBEDDED_CODE
        tokens.add *Token Lex.COD, symbol

      â¬© RESERVED_WORD
        tokens.add *Token Lex.ERR, symbol âŠ• " < RESERVED WORD"

      â€¼ tokens.add *Token Lex.ERR, symbol âŠ• " < UNKNOWN SYMBOL"
