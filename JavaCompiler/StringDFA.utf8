Â·Â·Â·
Deterministic Finite Acceptor of String Literals with Interpolation
Multiple physical lines are concatenated with a single space.
Pattern: ^â€¶((â¸¨[^â¸©]*â¸©)*([^â€³â¸¨]|\\[btnfr'"\\]|\\u[0-9A-Fa-f]{1,4})*)*â€³$
Â·Â·Â·
import java.util.LinkedList
import java.util.HashSet

â–  StringDFAâ¦‚ DFA

  stateâ¦‚ State
  â‰£ State
    WS Â· Start State ( WhiteSpace)
    IP Â· Interpolation
    IN Â· Indentation
    ES Â· Escape Sequence
    US Â· Unicode Sequence
    OK Â· Accept State
    ER Â· Trap State ( Error )

  openingDelimiterâ¦‚ String
  closingDelimiterâ¦‚ String
  tokensâ¦‚ LinkedListâŸ¨TokenâŸ©Â° Â· output

  interpolationâ¦‚ Lexer Â· Do not initialize here to avoid infinite callback!

  Â·Â·Â·
  For sake of performance, the last character of string closer or
  interpolation starter delimiters is compared to the actual character
  to consume, as a pre-check before detecting real closure.
  Â·Â·Â·
  delimiterTailsâ¦‚ HashSetâŸ¨CharacterâŸ©Â°

  Â·Â·Â·
  In order to check that String closing delimiter is not escaped,
  escape positions get registered during the tokenization.
  Â·Â·Â·
  escapesâ¦‚ HashSetâŸ¨IntegerâŸ©Â° Â· escape positions start from 1 (!)

  valueâ¦‚ StringBuilderÂ°
  â–¶ rTrim Â· remove whitespaces from the end of value
    ğŸ”ï¹– 0 < value.lengthÂ° and
        Character.isWhitespace value.charAt value.lengthÂ° - 1
        value.setLength value.lengthÂ° - 1

  â–¶ reset
  âº startâ¦‚ String
    tokens.clearÂ°
    if âˆ„ start
         openingDelimiter: ""
         closingDelimiter: "\n" Â· for TextDFA lines
    else
         openingDelimiter: start
         if Â¬ (The.closingDelimiters.containsKey start)
         or Â¬ (The.delimitedSequences.containsKey start)
         or Â¬ "String" â‰ˆ The.delimitedSequences.get start
              state: State.ER Â· do not accept any input
              return
         else
              closingDelimiter: The.closingDelimiters.get start

    if âˆ„ interpolation
         interpolation: *LexerÂ°

    delimiterTails.add closingDelimiter.charAt closingDelimiter.lengthÂ° - 1
    âˆ€ ipStart âˆˆ The.interpolationDelimitersâ¦‚ String
      delimiterTails.add ipStart.charAt ipStart.lengthÂ° - 1

    escapes.clearÂ°
    value.setLength 0
    state: State.WS

  â–¶ consumeâ¦‚ boolean
  âº câ¦‚ Character
    âˆ¢ state
      â¬© IP
        if interpolation.consume c
           return true
        else
           tokens.addAll interpolation.getTokensÂ°
           tokens.add *Token Lex.END, "Interpolation"
           state: State.WS
        fallthrough

      â¬© WS
        value â¨­ c
        if delimiterTails.contains c Â· pre-check possible closure
           if (value.toStringÂ°.endsWith closingDelimiter) and
           not escapes.contains value.lengthÂ° - closingDelimiter.lengthÂ° Â· end of string
               if (closingDelimiter â‰ˆ "\n") and
               not value.toStringÂ°.trimÂ°.isEmptyÂ°
                   rTrimÂ°
                   tokens.add *Token Lex.STR, value.toStringÂ°
               else
                   tokens.add *Token Lex.STR, value.substring 0,
                               value.lengthÂ° - closingDelimiter.lengthÂ°
               value.setLength 0
               state: State.OK
               return true
           
           for ipStart in The.interpolationDelimitersâ¦‚ String
               if (value.toStringÂ°.endsWith ipStart) and
               not escapes.contains value.lengthÂ° - ipStart.lengthÂ° Â· start of interpolation
                   tokens.add *Token Lex.STR, value.substring 0,
                               value.lengthÂ° - ipStart.lengthÂ°
                   tokens.add *Token Lex.BEG, "Interpolation"
                   interpolation.reset ipStart
                   value.setLength 0
                   state: State.IP
                   return true
        âˆ¢ c
          â¬© '\n'
            rTrimÂ°
            value â¨­ " "
            state: State.IN
          â¬© '\"'
            value.setCharAt value.lengthÂ° - 1, '\\'
            escapes.add value.lengthÂ°
            value â¨­ c
          â¬© '\\'
            escapes.add value.lengthÂ°
            state: State.ES

      â¬© IN
        if Â¬ c.isWhitespace c
             state: State.WS
             return consume c
        if closingDelimiter â‰ˆ "\n" Â· Text line
           if c = '\n'
              tokens.add *Token Lex.STR, value.toStringÂ°
              value.setLength 0
              state: State.OK
              return true
           value â¨­ c Â· preserve indentation for Text line

      â¬© ES
        value â¨­ c
        âˆ¢ c
          â¬© '\n'
            value.setLength value.lengthÂ° - 2 Â· concatenate with next line
            state: State.IN
          â¬© 'b', 't', 'n', 'f', 'r', '\'', '\"', '\\'
            state: State.WS
          â¬© 'u':
            state: State.US
          else
            state: State.ER

      â¬© US
        value â¨­ c
        if 0 â‰¤ c.digit c, 16
           if value.lengthÂ° = 6
              state: State.WS
           return true
        state: State.ER

      else return false Â· OK, ER
      
    return true

  â–¶ getTokensâ¦‚ LinkedListâŸ¨TokenâŸ©
    if state = State.IP
       tokens.addAll interpolation.getTokensÂ°
       tokens.add *Token Lex.ERR, " < INCOMPLETE STRING INTERPOLATION"
    if state â‰  State.OK
    or value.lengthÂ° > 0
       tokens.add *Token Lex.ERR, openingDelimiter âŠ• value.toStringÂ°
                                âŠ• " < INVALID STRING LITERAL"
    return tokens
