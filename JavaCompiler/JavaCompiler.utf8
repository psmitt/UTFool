import java.util.LinkedList

â–  JavaCompiler

  linesâ¦‚ LinkedListâŸ¨StringâŸ©Â° Â· output
  resultâ¦‚ StringBuilderÂ° Â· current compilation fragment
  blocksâ¦‚ LinkedListâŸ¨BlockâŸ©Â° Â· block stack

  â–¶ TABâ¦‚ String âº iâ¦‚ int
    â *(String *char[i]).replace "\u0000", "\t"

  â–¶ reduceBlocks
    blockâ¦‚ Block: blocks.removeLastÂ°
    âˆ¢ block.name
      â¬© CLASS, SELECTION
        lines.add (TAB blocks.sizeÂ°) âŠ• "}"
      â¬© CASE
        unless block.value â‰ˆ "nobreak"
          lines.add (TAB blocks.sizeÂ° + 1) âŠ• "break;"
        lines.add (TAB blocks.sizeÂ°) âŠ• "}"
      â€¼ lines.add (TAB blocks.sizeÂ°) âŠ• block.value

  parserâ¦‚ ParserÂ° Â· for Expressions
  lineâ¦‚ Line Â· to compile
  limitâ¦‚ int Â· number of tokens in line

  â–¶ tokenâ¦‚ Token âº iâ¦‚ int
    â i < limit ? line.tokens.get i ! null

  typeâ¦‚ StringBuilderÂ° Â· Name, ClassName, TypeName, Type

  â–¶ getTypeâ¦‚ int
  âº iâ¦‚ int Â· points to TypeSign before TypeName
    type.setLength 0
    type.append (token â—¤i).value
    iâ—¥
    ğŸ”ï¹– (token i) ?â‰ˆ Lex.OPR, "Access"
        type.(append "." â¨­ (token â—¤i).value)
        iâ—¥
    ğŸ”ï¹– (token i) ?â‰ˆ Lex.BEG, "Array"
        type.append "["
        unless (token â—¤i) â‰ˆ Lex.END, "Array" Â· fixed length array
               i: parser.resetÂ°.parse line, i
               type.append compile parser.getExpressionÂ°
        else iâ—¥ Â· step over closing delimiter
        type.append "]"
    return i

  â–¶ addTypeâ¦‚ int âº iâ¦‚ int
    tâ¦‚ int: getType i
    result.append type
    return t

  variableâ¦‚ StringBuilderÂ°

  â–¶ getVariableâ¦‚ int
  âº iâ¦‚ int Â· points to variable name
    nameâ¦‚ String: (token i).value
    i: getType i + 1
    variable.setLength 0
    variable.(append type.toStringÂ°.replaceAll "\\[[^\\]]*\\]", "[]"
              â¨­ " " â¨­ name)
    if i â‰¥ limit âˆ¨ (token i).name = Lex.COM
       if type.toStringÂ°.matches ".*\\[.+\\].*" Â· fixed length array
          variable.(append " = new " â¨­ type)
       return i
    if (token i) â‰ˆ Lex.KEY, "assign"
       variable.append " = "
       isArrayâ¦‚ boolean: (token â—¤i) â‰ˆ Lex.BEG, "Array" Â· array initializer
       i: parser.resetÂ°.parse line, i
       if isArray
          variable.append (compile parser.getExpressionÂ°)
                         .(replaceAll "\\[", "{").replaceAll "\\]", "}"
       else
          variable.append compile parser.getExpressionÂ°
       return i
    if (token i) â‰ˆ Lex.OPR, "Invocation"
       variable.(append " = new " â¨­ type â¨­ "()")
       return i + 1
    âƒ«else assign constructor call with arguments
    line.tokens.add i, *Token Lex.NAM, type.toStringÂ°
    limitâ—¥
    i: parser.resetÂ°.parse line, i
    variable.(append " = new " â¨­ compile parser.getExpressionÂ°)
    return i

  â–¶ compileâ¦‚ boolean
  âº lexicalâ¦‚ Line
    line:  lexical
    limit: line.tokens.sizeÂ°

    if line.tokens.getFirstÂ°.name = Lex.COM
     âˆ§ line.indentation = lines.getLastÂ°.(lastIndexOf '\t') + 1
    ÍHead comment of a block, like this one
       lines.add (TAB line.indentation) âŠ• "// "
                  âŠ• line.tokens.getFirstÂ°.value
       return true

    if blocks.sizeÂ° < line.indentation Â· start of inner scope
       lines.add (TAB blocks.sizeÂ°) âŠ• "{"
       blocks.add *Block Head.ANONYM

    ğŸ”ï¹– blocks.sizeÂ° > line.indentation Â· end of blocks
        reduceBlocksÂ°

    ÍStart of line compilation
    result.setLength 0
    result.append TAB line.indentation

    startOfBlockâ¦‚ Boolean: null
    iâ¦‚ int: 0
    ğŸ”ï¹– i < limit
        âˆ¢ (token i).name
          â¬© COD
            result.append (token iâ—¥).value
            if i â‰¥ limit
               lines.add result.toStringÂ°
               return true
            result.append " "
            continue

          â¬© COM
            if âˆ„ startOfBlock Â· comment line or line comment after COD
                 result.(append "// " â¨­ (token i).value)
                 lines.add result.toStringÂ°
                 return true
            âƒ«comment line after else:
            return endOfLine i, startOfBlock

          â¬© KEY
            âˆ¢ (token i).value
              â¬© "label"
                result.(append (token â—¤i).value â¨­ ":")
                if â—¤i < limit âˆ§ (token i).name = Lex.COM
                   result.(append " // " â¨­ (token i).value)
                lines.add result.toStringÂ°
                return true

              â¬© "constants"
                result.(append "enum " â¨­ (token â—¤i).value)
                blocks.add *Block Head.CONSTANTS
                return endOfLine â—¤i, true

              â¬© "interface"
                result.append "public interface "
                i: addType i Â· interface name
                ğŸ”ï¹— endOfLine i, true Â· superinterfaces
                   result.append â†µ
                     ((token i).name = Lex.OPR ? ", " ! " extends ")
                   i: addType i
                return true

              â¬© "class"
                result.append "public class "
                i: getType i Â· class name
                result.append type
                cnameâ¦‚ String[]: type.toStringÂ°.split "<", 2
                blocks.add *Block Head.CLASS, cname[0] Â· constructor name
                ğŸ”ï¹— endOfLine i, true Â· superclass and/or superinterfaces
                   result.append (
                     (token i).name = Lex.OPR ? ", " !
                     (token i).value â‰ˆ "super" ? " extends " !
                                                 " implements ")
                   i: addType i
                return true

              â¬© "function"
                result.append "public "
                nameâ¦‚ String: (token â—¤i).value
                iâ—¥
                if name â‰ˆ "constructor" Â· replace with class name
                   result.append blocks.getLastÂ°.value
                else
                   if (token i) ?â‰ˆ Lex.KEY, "as"
                      i: addType i
                      result.append " "
                   else
                      result.append "void "
                   result.append name
                thrownTypeâ¦‚ StringBuilder: null
                if (token i) ?â‰ˆ Lex.KEY, "throw"
                   i: getType i
                   thrownType: *StringBuilder type
                   ğŸ”ï¹– (token i) ?â‰ˆ Lex.OPR, "ListSeparator"
                       i: getType i
                       thrownType.(append ", " â¨­ type)
                result.append "("
                parameterListâ¦‚ boolean: false
                ğŸ”ï¹– (token i) ?â‰ˆ Lex.KEY, "parameter"
                    result.append ", " if parameterList
                    parameterList: true
                    name: (token â—¤i).value
                    i: addType â—¤i
                    result.(append " " â¨­ name)
                result.append ")"
                result.(append " throws " â¨­ thrownType) if âˆƒ thrownType
                return endOfLine i, Â¬(token 0) â‰ˆ Lex.COD, "abstract"

              â¬© "iterate"
                if â—¤i â‰¥ limit âˆ¨ (token i).name = Lex.COM
                   result.append "do"
                   return endOfLine i, true
                unless (token i) â‰ˆ Lex.KEY, "while"
                    or (token i) â‰ˆ Lex.KEY, "until"

                    âƒ«For-loop:
                    isMapâ¦‚ boolean: false
                    firstParameterâ¦‚ String: (token i).value
                    secondParameterâ¦‚ String: null
                    if (token â—¤i) â‰ˆ Lex.KEY, "by" Â· loop counter
                        secondParameter: (token â—¤i).value
                        iâ—¥ Â· points to "in"
                    if (token i) â‰ˆ Lex.KEY, "of"
                        isMap: true
                        if (token i + 2) ?â‰ˆ Lex.KEY, "in" Â· Value, Key in Map
                            secondParameter: (token â—¤i).value
                            iâ—¥ Â· points to "in"
                    isArrayâ¦‚ int: (token â—¤i) â‰ˆ Lex.BEG, "Array" ? 1 ! 0
                    i: parser.resetÂ°.parse line, i + isArray
                    expressionâ¦‚ String: compile parser.getExpressionÂ°

                    âƒ«.forEach unless Map with String key:
                    if  (i â‰¥ limit âˆ¨ (token i).name = Lex.COM)
                    and (Â¬ isMap âˆ¨ âˆƒ secondParameter)
                        result.(append "(" â¨­ expression â¨­ ").forEach(")
                        if âˆƒ secondParameter Â· second is the key/index
                            result.(append "(" â¨­ secondParameter
                                        â¨­ ", " â¨­ firstParameter â¨­ ")")
                        else
                            result.append firstParameter
                        result.append " ->"
                        blocks.add *Block Head.ANONYM, "});"
                        return endOfLine i, true

                    âƒ«Range:
                    if (token i) ?â‰ˆ Lex.KEY, "ellipsis"
                        result.(append "for (int " â¨­ firstParameter
                                â¨­ " = (int) " â¨­ expression â¨­ "; "
                                â¨­ firstParameter)
                        relationâ¦‚ String: "Less"
                        if (token â—¤i).name = Lex.OPR
                        and The.precedences.get (token i).value
                          = The.precedences.get "Less" Â· relational operator
                            relation: (token iâ—¥).value
                        operationâ¦‚ String: "++" Â· default
                        âˆ¢ relation
                          â¬© "Equal", "Identical"
                            result.append " == "
                          â¬© "Greater"
                            result.append " > "
                            operation: "--"
                          â¬© "GreaterEqual"
                            result.append " >= "
                            operation: "--"
                          â¬© "Less"
                            result.append " < "
                          â¬© "LessEqual"
                            result.append " <= "
                          â¬© "NotEqual", "NotIdentical"
                            result.append " != "
                        i: parser.resetÂ°.parse line, i Â· end limit
                        result.(append compile parser.getExpressionÂ°
                                â¨­ "; " â¨­ firstParameter)
                        if (token i) ?â‰ˆ Lex.KEY, "by"
                            binaryâ¦‚ String
                            if (token â—¤i).name = Lex.OPR
                                binary: compoundAssignment (token i).value
                                if âˆ„ binary
                                     binary: " = "
                                     line.tokens.add i,
                                          *Token Lex.NAM, firstParameter
                                     limitâ—¥
                            else
                                binary: operation â‰ˆ "--" ? " -= " ! " += "
                            i: parser.resetÂ°.parse line, i Â· step
                            result.(append binary
                                    â¨­ compile parser.getExpressionÂ°)
                        else
                            result.append operation
                        result.append ")"
                        return endOfLine i, true

                    keyTypeâ¦‚ String: "String" Â· default key type of Maps
                    itemTypeâ¦‚ String: null
                    if (token i) ?â‰ˆ Lex.KEY, "as"
                        i: getType i
                        itemType: type.toStringÂ°
                        if âˆ„ secondParameter
                             keyType: itemType
                        else if (token i) ?â‰ˆ Lex.OPR, "ListSeparator"
                             i: getType i
                             keyType: type.toStringÂ°

                    if isMap
                       result.(append "for (" â¨­ keyType â¨­ " "
                               â¨­ (secondParameter âˆ firstParameter)
                               â¨­ " : (" â¨­ expression â¨­ ").getKeys())")
                       return endOfLine i, true if âˆ„ secondParameter
                       blocks.add *Block Head.ANONYM
                       result.append " {"
                       if i < limit âˆ§ (token i).name = Lex.COM
                          result.(append " // " â¨­ (token i).value)
                       result.(append System.lineSeparatorÂ°
                            â¨­ (TAB line.indentation + 1) â¨­ itemType
                            â¨­ " " â¨­ firstParameter â¨­ " = (" â¨­ expression
                            â¨­ ").get(" â¨­ secondParameter â¨­ ");")
                       lines.add result.toStringÂ°
                       return true
                    else Â· Iterable Collection
                       if âˆƒ secondParameter Â· Item Index
                            result.(append "{int " â¨­ secondParameter
                                    â¨­ " = 0;" â¨­ System.lineSeparatorÂ°
                                    â¨­ (TAB line.indentation))
                       result.(append "for (" â¨­ itemType â¨­ " "
                               â¨­ firstParameter â¨­ " : ")
                       if isArray = 1
                          result.(append "new " â¨­ itemType â¨­ "[]{"
                                â¨­ compile parser.getExpressionÂ° â¨­ "})")
                       else
                          result.(append compile parser.getExpressionÂ°
                                  â¨­ ")")
                       if âˆƒ secondParameter Â· increment Index
                          blocks.add *Block Head.ANONYM,
                                     "\t" âŠ• secondParameter âŠ• "++;"
                                     âŠ• System.lineSeparator()
                                     âŠ• (TAB line.indentation) âŠ• "}}"
                       return endOfLine i, true

                fallthrough Â· while or until

              â¬© "if"
                if Â¬ blocks.isEmptyÂ°
                   âˆ§ blocks.getLastÂ°.name = Head.SELECTION
                     blocks.add *Block Head.CASE
                     i: parser.resetÂ°.parse line, â—¤i
                     âˆ€ value âˆˆ (compile parser.getExpressionÂ°)
                                 .split ", " â¦‚ String
                       lines.add *(StringBuilder TAB line.indentation)
                                 .(append "case " â¨­ value â¨­ ":").toStringÂ°
                    result: *(StringBuilder lines.removeLastÂ°)
                    if (token i) ?â‰ˆ Lex.KEY, "then"
                        result.append " { "
                        iâ—¥
                        continue
                    return endOfLine i, true

                fallthrough

              â¬© "while", "until", "select"
                if (token i).value â‰ˆ "select"
                    blocks.add *Block Head.SELECTION
                    result.append "switch ("
                else
                    result.(append (token i).value â¨­ " (")
                i: parser.resetÂ°.parse line, â—¤i
                result.(append compile parser.getExpressionÂ° â¨­ ")")
                if (token i) ?â‰ˆ Lex.KEY, "then"
                    result.append " "
                    iâ—¥
                    continue
                return endOfLine i, Â¬(token 0).value â‰ˆ "while"

              â¬© "else"
                startOfBlock: true
                if Â¬ blocks.isEmptyÂ° âˆ§ blocks.getLastÂ°.name = Head.SELECTION
                     result.append "default: "
                else result.append "else "
                return true if endOfLine â—¤i, true
                continue

              â¬© "try"
                result.append "try "
                return true if endOfLine â—¤i, true
                âƒ«try-with-resources:
                result.append "(")
                ğŸ”ï¹– (token i) ?â‰ˆ Lex.KEY, "parameter"
                    i: getVariable â—¤i
                    result.(append System.lineSeparatorÂ°
                         â¨­ (TAB line.indentation + 1)
                         â¨­ (variable.toStringÂ°.replace "(\u0001)", "")
                         â¨­ ";")
                result.(append System.lineSeparatorÂ°
                     â¨­ (TAB line.indentation + 1) â¨­ ")")
                return endOfLine i, true

              â¬© "catch"
                result.append "catch "
                return true if endOfLine â—¤i, true
                result.append "("
                nameâ¦‚ String: (token i).value
                i: addType â—¤i
                result.(append " " â¨­ name â¨­ ")")
                return endOfLine i, true

              â¬© "finally"
                result.append "finally"
                return endOfLine â—¤i, true

              â¬© "fallthrough"
                result.append "// "
                fallthrough

              â€¼ Â· other control transfer statements
                result.append (token i).value
                if â—¤i < limit and (token i).name â‰  Lex.COM
                   unless (token i).name = Lex.KEY Â· target expression
                      i: parser.resetÂ°.parse line, i
                      result.(append " " â¨­ compile parser.getExpressionÂ°)
                   if (token i) ?â‰ˆ Lex.KEY, "if" Â· conditional statement
                      i: parser.resetÂ°.parse line, i + 1
                      realResultâ¦‚ StringBuilder TAB line.indentation
                      realResult.(append "if ("
                                  â¨­ compile parser.getExpressionÂ°
                                  â¨­ ") " â¨­ result.toStringÂ°.trimÂ°)
                      result: realResult
                if Â¬blocks.isEmptyÂ°
                and blocks.getLastÂ°.name = Head.CASE
                and Â¬ result.toStringÂ°.trimÂ°.startsWith "if"
                and Â¬ result.toStringÂ°.trimÂ°.startsWith "else"
                    blocks.removeLastÂ°
                    blocks.add *Block Head.CASE, "nobreak"
                return endOfLine i, false

            fallthrough Â· to avoid unreachable break

          â¬© OPR
            if (token i) â‰ˆ Lex.OPR, "Invocation"
            âƒ«Call of anonymous function or method of anonymous class:
                result: *StringBuilder lines.removeLastÂ°
                                            .replaceFirst "..$", ""
                if â—¤i â‰¥ limit âˆ¨ (token i).name = Lex.COM
                   result.append "())"
                   return endOfLine i, false
                unless (token i) â‰ˆ Lex.OPR, "Access"
                       âƒ«argumentlist of anonymous function
                       i: parser.resetÂ°.parse line, i
                    result.(append "(" â¨­ compile parser.getExpressionÂ°
                                       â¨­ "))")
                    return endOfLine i, false
                âƒ«Call method of anonymous class
                result.append "."
                iâ—¥ Â· points to method name

            fallthrough

          â¬© NAM Â· constant, variable, function, assignments
            if i = 0
             âˆ§ Â¬ blocks.isEmptyÂ°
             âˆ§ blocks.getLastÂ°.name = Head.CONSTANTS Â· enum constant
               i: parser.resetÂ°.parse line, i
               result.(append compile parser.getExpressionÂ° â¨­ ",")
               if i < limit âˆ§ (token i).name = Lex.COM
                  result.(append " // " â¨­ (token i).value)
               lines.add result.toStringÂ°
               return true
            if (token i + 1) ?â‰ˆ Lex.KEY, "as" Â· variable definition
               i: getVariable i
               result.append variable
               return endOfLine i, false

            âƒ«Reference:
            i: parser.resetÂ°.parse line, i
            referenceâ¦‚ String: compile parser.getExpressionÂ°
            result.append reference
            if (token 0) â‰ˆ Lex.OPR, "Invocation" Â· anonymous function call
                result.append ")"
            if (token i) ?â‰ˆ Lex.KEY, "if" Â· conditional statement
                i: parser.resetÂ°.parse line, i + 1
                realResultâ¦‚ StringBuilder TAB line.indentation
                realResult.(append "if (" â¨­ compile parser.getExpressionÂ°
                            â¨­ ") " â¨­ result.toStringÂ°.trimÂ°)
                result: realResult
            return true if endOfLine i, false
            Â· function call, increment/decrement, COD + reference

            âƒ«Assignments:
            unless parser.operatorStack.isEmptyÂ°
              if (token i - 1) â‰ˆ Lex.OPR, "TernaryTrue" Â· existential
                  result.insert 0, "if (null == "
                  result.(append ") " â¨­ reference â¨­ " = ")
              else Â· compound assignment
                  operatorâ¦‚ String: compoundAssignment â†µ
                                    parser.operatorStack.getLastÂ°.value
                  if âˆƒ operator then result.append operator
                  else
                      i: parser.parse line, i + 1
                      result.(append " = " â¨­ compile parser.getExpressionÂ°)
                      return endOfLine i, false
            else result.append " = "
            i: parser.resetÂ°.parse line, i + 1
            result.append compile parser.getExpressionÂ°
            if (token i) ?â‰ˆ Lex.KEY, "if" Â· conditional statement
                i: parser.resetÂ°.parse line, i + 1
                realResultâ¦‚ StringBuilder TAB line.indentation
                realResult.(append "if (" â¨­ compile parser.getExpressionÂ°
                            â¨­ ") " â¨­ result.toStringÂ°.trimÂ°)
                result: realResult
            return endOfLine i, false
    return true

  â–¶ compoundAssignmentâ¦‚ String
  âº operatorâ¦‚ String
    âˆ¢ operator
      â¬© "Addition"       â­† â " += "
      â¬© "BitAnd"         â­† â " &= "
      â¬© "BitOr"          â­† â " |= "
      â¬© "BitXor"         â­† â " ^= "
      â¬© "Concatenation"  â­† â " += "
      â¬© "Division"       â­† â " /= "
      â¬© "Multiplication" â­† â " *= "
      â¬© "Quotient"       â­† â " /= "
      â¬© "ShiftLeft"      â­† â " <<= "
      â¬© "ShiftRight"     â­† â " >>= "
      â¬© "Subtraction"    â­† â " -= "
      â€¼ â null

  â–¶ endOfLineâ¦‚ boolean
  âº iâ¦‚ int Â· points to end of line
  âº startOfBlockâ¦‚ boolean
    if i < limit
       âˆ¢ (token i).name
         â¬© COM
           result.(append (startOfBlock ? " {" ! ";") â¨­ " // "
                   â¨­ (token i).value)
         â¬© KEY
           if 0 â‰¤ result.indexOf "\u0001" Â· anonymous class or function
              closingParenthesesâ¦‚ String:
                (TAB result.lengthÂ° - result.(indexOf "\u0001") - 1)
                .replaceAll "\t", ")"
              result.setLength result.indexOf "\u0001"
              argumentListâ¦‚ boolean: false
              âˆ¢ (token i).value
                â¬© "class"
                  result.append " {"
                  blocks.add *Block Head.ANONYM,
                                    "}" âŠ• closingParentheses âŠ• ";"
                  if â—¤i < limit âˆ§ (token i).name = Lex.COM
                     result.(append " // " â¨­ (token i).value)
                  lines.add result.toStringÂ°
                  return true

                â¬© "parameter"
                  argumentList: true
                  result.append "("
                  ğŸ”ï¹— (token â—¤i) â‰ˆ Lex.KEY, "function"
                      if (token i) â‰ˆ Lex.OPR, "ListSeparator"
                          result.append ", "
                      else Â· NAM
                          result.append (token i).value)
                  result.append ")"
                  fallthrough

                â¬© "function"
                  result.append "()" unless argumentList
                  result.append " -> {"
                  blocks.add *Block Head.ANONYM,
                                    "}" âŠ• closingParentheses âŠ• ";"
                  if â—¤i < limit âˆ§ (token i).name = Lex.COM
                     result.(append " // " â¨­ (token i).value)
                  lines.add result.toStringÂ°
                  return true
           else return false
         else return false
    else
       result.append (startOfBlock ? " {" ! ";")
    lines.add result.toStringÂ°
    if blocks.sizeÂ° â‰¤ line.indentation and startOfBlock
       blocks.add *Block Head.ANONYM, "}"
    return true

  â–¶ compileâ¦‚ String
  âº expressionâ¦‚ Expression
    parentheticalâ¦‚ boolean:
       expression.root.name = Lex.OPR and
       (expression.root.value â‰ˆ "Expression"
        âˆ§Â¬ expression.left.root â‰ˆ Lex.OPR, "Array"
        âˆ§Â¬ expression.left.root â‰ˆ Lex.OPR, "FunctionCall"
        âˆ§Â¬ expression.left.root â‰ˆ Lex.OPR, "Invocation"
       or
         Â¬ expression.root.value â‰ˆ "Expression"
        âˆ§Â¬ expression.root.value â‰ˆ "Access"
        âˆ§Â¬ expression.root.value â‰ˆ "Array"
        âˆ§Â¬ expression.root.value â‰ˆ "ListSeparator"
        âˆ§Â¬ expression.root.value â‰ˆ "FunctionCall"
        âˆ§Â¬ expression.root.value â‰ˆ "FirstTrue"
         âˆ§ The.arities.get expression.root.value = 2)

    resultâ¦‚ StringBuilderÂ°

    if expression.root.name = Lex.OPR
       âˆ¢ expression.root.value
         â¬© "Cast"           â­† result.append "("
         â¬© "Exponentiation" â­† result.append "Math.pow"
         â¬© "RotateLeft"     â­† result.append "Integer.rotateLeft"
         â¬© "RotateRight"    â­† result.append "Integer.rotateRight"

    result.append "(" if parenthetical
    result.append compile expression.left if âˆƒ expression.left
    result.append ")" if  expression.root â‰ˆ Lex.OPR, "Cast"

    âˆ¢ expression.root.name
      â¬© OPR
        âˆ¢ expression.root.value
          â¬© "Access"         â­† result.append '.'
          â¬© "Addition"       â­† result.append " + "
          â¬© "And"            â­† result.append " && "
          â¬© "Array"          â­† result.append '['
          â¬© "BitAnd"         â­† result.append " & "
          â¬© "BitOr"          â­† result.append " | "
          â¬© "BitXor"         â­† result.append " ^ "
          â¬© "Complement"     â­† result.append '~'
          â¬© "Concatenation"  â­† result.append " + "
          â¬© "Division"       â­† result.append " / "
          â¬© "Equal"          â­† result.append " == "
          â¬© "Exponentiation" â­† result.append ", " Â· Math.pow
          â¬© "FirstTrue"      â­† result.append expression.root.value Â· ???
          â¬© "FunctionCall"   â­† result.append '('
          â¬© "Invocation"     â­† result.append '('
          â¬© "Greater"        â­† result.append " > "
          â¬© "GreaterEqual"   â­† result.append " >= "
          â¬© "Identical"      â­† result.append " == "
          â¬© "Less"           â­† result.append " < "
          â¬© "LessEqual"      â­† result.append " <= "
          â¬© "ListSeparator"  â­† result.append ", "
          â¬© "Minus"          â­† result.append '-'
          â¬© "Modulus"        â­† result.append " % "
          â¬© "Multiplication" â­† result.append " * "
          â¬© "Nand"           â­† result.append expression.root.value Â· ???
          â¬© "New"            â­† result.append "new "
          â¬© "Nor"            â­† result.append expression.root.value Â· ???
          â¬© "Not"            â­† result.append '!'
          â¬© "NotEqual"       â­† result.append " != "
          â¬© "NotIdentical"   â­† result.append " != "
          â¬© "Or"             â­† result.append " || "
          â¬© "PostDecrement"  â­† result.append "--"
          â¬© "PreDecrement"   â­† result.append "--"
          â¬© "PostIncrement"  â­† result.append "++"
          â¬© "PreIncrement"   â­† result.append "++"
          â¬© "RotateLeft"     â­† result.append ", " Â· Integer.rotateLeft
          â¬© "RotateRight"    â­† result.append ", " Â· Integer.rotateRight
          â¬© "Quotient"       â­† result.append " / "
          â¬© "ShiftLeftZero"  â­† result.append " << "
          â¬© "ShiftRightSign" â­† result.append " >> "
          â¬© "ShiftRightZero" â­† result.append " >>> "
          â¬© "Subtraction"    â­† result.append " - "
          â¬© "TernaryTrue"    â­† result.append " ? "
          â¬© "TernaryFalse"   â­† result.append " : "
          â¬© "Xor"            â­† result.append " ^ "

      â¬© CHR â­† result.(append "'" â¨­ expression.root.value â¨­ "'")
      â¬© STR â­† result.(append '"' â¨­ expression.root.value â¨­ '"')
      â¬© KEY Â· anonymous class or function
        âˆ¢ expression.root.value
          â¬© "class", "function", "parameter"
            return result.(append '\u0001').toStringÂ° Â· start of block

      â€¼ result.append expression.root.value

    result.append compile expression.right if âˆƒ expression.right
    result.append ']' if expression.root â‰ˆ Lex.OPR, "Array"
    result.append ')' if expression.root â‰ˆ Lex.OPR, "FunctionCall"
                      or expression.root â‰ˆ Lex.OPR, "Invocation"
                      or parenthetical

    return result.toStringÂ°

  â–¶ getSourceâ¦‚ String
    ğŸ”ï¹– blocks.sizeÂ° > 0 Â· end of blocks
        reduceBlocksÂ°
    resultâ¦‚ StringBuilderÂ°
    âˆ€ line âˆˆ linesâ¦‚ String
      result.(append line â¨­ System.lineSeparatorÂ°)
    return result.toStringÂ°
